/*
 * @source: https://arbiscan.io/address/0x62C5aa8277E49B3EAd43dC67453EC91dC6826403
 * @author: Proxy
 * @vulnerable_at_lines: [MANUAL ANNOTATION REQUIRED]
 * @category: REENTRANCY
 * @exploit_amount: $1,000,000
 * @date: 2023-04-04
 * @blockchain: arbitrum
 * @description: Read-only reentrancy via Balancer exitPool() let attacker borrow against stale balances; ~$1M withdrawn (most later returned).
 */

{{
  "language": "Solidity",
  "sources": {
    "src/interface/core/IAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IAccount {\n    function activate() external;\n    function deactivate() external;\n    function addAsset(address token) external;\n    function addBorrow(address token) external;\n    function removeAsset(address token) external;\n    function sweepTo(address toAddress) external;\n    function removeBorrow(address token) external;\n    function init(address accountManager) external;\n    function hasAsset(address) external returns (bool);\n    function assets(uint) external returns (address);\n    function hasNoDebt() external view returns (bool);\n    function activationBlock() external view returns (uint);\n    function accountManager() external view returns (address);\n    function getAssets() external view returns (address[] memory);\n    function getBorrows() external view returns (address[] memory);\n    function exec(\n        address target,\n        uint amt,\n        bytes calldata data\n    ) external returns (bool, bytes memory);\n}\n"
    },
    "src/interface/tokens/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value)\n        external returns (bool success);\n    function approve(address _spender, uint256 _value)\n        external returns (bool success);\n    function allowance(address _owner, address _spender)\n        external view returns (uint256 remaining);\n    function transferFrom(address _from, address _to, uint256 _value)\n        external returns (bool success);\n}"
    },
    "src/proxy/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {StorageSlot} from \"../utils/Storage.sol\";\n\nabstract contract BaseProxy {\n\n    bytes32 private constant _ADMIN_SLOT =\n        bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1);\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    modifier adminOnly() {\n        if (msg.sender != getAdmin()) revert Errors.AdminOnly();\n        _;\n    }\n\n    function changeAdmin(address newAdmin) external adminOnly {\n        _setAdmin(newAdmin);\n    }\n\n    function getAdmin() public view returns (address) {\n        return StorageSlot.getAddressAt(_ADMIN_SLOT);\n    }\n\n    function _setAdmin(address admin) internal {\n        if (admin == address(0)) revert Errors.ZeroAddress();\n        emit AdminChanged(getAdmin(), admin);\n        StorageSlot.setAddressAt(_ADMIN_SLOT, admin);\n    }\n\n    function getImplementation() public virtual returns (address);\n\n    function _delegate(address impl) internal virtual {\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getImplementation());\n    }\n\n    receive() external payable {\n        _delegate(getImplementation());\n    }\n}"
    },
    "src/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {BaseProxy} from \"./BaseProxy.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\nimport {StorageSlot} from \"../utils/Storage.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\n\ncontract Proxy is BaseProxy {\n\n    bytes32 private constant _IMPL_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n\n    event Upgraded(address indexed newImplementation);\n\n    constructor(address _logic) {\n        _setImplementation(_logic);\n        _setAdmin(msg.sender);\n    }\n\n    function changeImplementation(address implementation) external adminOnly {\n        _setImplementation(implementation);\n    }\n\n    function upgradeToAndCall(address implementation, bytes calldata data) external adminOnly {\n        _upgradeToAndCall(implementation, data);\n    }\n\n    function getImplementation() public override view returns (address) {\n        return StorageSlot.getAddressAt(_IMPL_SLOT);\n    }\n\n    function _setImplementation(address implementation) internal {\n        if (implementation == address(0)) revert Errors.ZeroAddress();\n        StorageSlot.setAddressAt(_IMPL_SLOT, implementation);\n        emit Upgraded(implementation);\n    }\n\n    function _upgradeToAndCall(address implementation, bytes calldata data) internal {\n        _setImplementation(implementation);\n        if (data.length > 0) Helpers.functionDelegateCall(implementation, data);\n    }\n}"
    },
    "src/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary Errors {\n    error AdminOnly();\n    error MaxSupply();\n    error ZeroShares();\n    error ZeroAssets();\n    error ZeroAddress();\n    error MinimumShares();\n    error ContractPaused();\n    error OutstandingDebt();\n    error AccountOwnerOnly();\n    error TokenNotContract();\n    error AddressNotContract();\n    error ContractNotPaused();\n    error LTokenUnavailable();\n    error LiquidationFailed();\n    error EthTransferFailure();\n    error AccountManagerOnly();\n    error RiskThresholdBreached();\n    error FunctionCallRestricted();\n    error AccountNotLiquidatable();\n    error CollateralTypeRestricted();\n    error IncorrectConstructorArgs();\n    error ContractAlreadyInitialized();\n    error AccountDeactivationFailure();\n    error AccountInteractionFailure(address, address, uint, bytes);\n}"
    },
    "src/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.17;\n\nimport {Errors} from \"./Errors.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\n\n/// @author Modified from Rari-Capital/Solmate\nlibrary Helpers {\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amt\n    ) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amt)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amt\n    ) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amt)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeTransferEth(address to, uint256 amt) internal {\n        (bool success, ) = to.call{value: amt}(new bytes(0));\n        if(!success) revert Errors.EthTransferFailure();\n    }\n\n    function balanceOf(address token, address owner) internal view returns (uint) {\n        return IERC20(token).balanceOf(owner);\n    }\n\n    function withdrawEth(address account, address to, uint amt) internal {\n        (bool success, ) = IAccount(account).exec(to, amt, new bytes(0));\n        if(!success) revert Errors.EthTransferFailure();\n    }\n\n    function withdraw(address account, address to, address token, uint amt) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = IAccount(account).exec(token, 0,\n                abi.encodeWithSelector(IERC20.transfer.selector, to, amt));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(address account, address token, address spender, uint amt) internal {\n        (bool success, bytes memory data) = IAccount(account).exec(token, 0,\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amt));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function isContract(address token) internal view returns (bool) {\n        return token.code.length > 0;\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes calldata data\n    ) internal {\n        if (!isContract(target)) revert Errors.AddressNotContract();\n        (bool success, ) = target.delegatecall(data);\n        require(success, \"CALL_FAILED\");\n    }\n}"
    },
    "src/utils/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary StorageSlot {\n    function getAddressAt(bytes32 slot) internal view returns (address a) {\n        assembly {\n            a := sload(slot)\n        }\n    }\n\n    function setAddressAt(bytes32 slot, address address_) internal {\n        assembly {\n            sstore(slot, address_)\n        }\n    }\n}"
    }
  },
  "settings": {
    "remappings": [
      "controller/=lib/controller/src/",
      "ds-test/=lib/solmate/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "oracle/=lib/oracle/src/",
      "solidity-bytes-utils/=lib/controller/lib/solidity-bytes-utils/contracts/",
      "solmate/=lib/solmate/src/",
      "v3-core/=lib/oracle/lib/v3-core/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}